{
  "name": "Tallier",
  "functions": [
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/+XdZZOTZxSH8V0gSd27uLu1ySbZJFVK3alSL6Rk6y1V6qXU3XB390/IuWbCwAt4xb0z3HNl5j9590x+m+yj5z7nZE9Pz7aeM6/e7vuC7nv5wl6VQmyjcI7tVssDtVqn0d+pVCtLy/2tdrNertXbA81Ks1Jv1pf1N6vVTrPWbLTarUa5ValVO5XBeqs62N1wId1nLA+FuxjbKA6Bu3iRu0uxjdIQuEuJ3ef7vV/o5xw5RJ9zWOLvqTeheVQm5mEJzaMzMQ9PaB6TiXlEQvPYTMyFhOZxmZiLCc3jMzGXEponZGIemdA8UWieJDRPFpqnCM1TheZpQvN0oXmG0DxTaJ4lNM8WmucIzXOF5nlC83yh+Sah+WahuSw0V4TmfqG5KjTXhOa60DwgNDeE5qbQ3BKabxGabxWabxOabxea7xCa7xSaFwjNdwnNC4Xmu4Xme4Tme4Xm+4Tm+4XmB4TmB4Xmh4Tmh4XmR4TmR4Xmx4Tmx4XmRULzE0Lzk0LzU0Lz00LzM0Lzs0LzYqH5OaH5eaH5BaH5RaH5JaH5ZaH5FaH5VaF5idC8VGhuC82vCc3LhOaO0DwoNL8uNL8hNL8pNL8lNL8tNL8jNL8rNL8nNL8vNC8Xmj8Qmj8Umj8Smj8Wmj8Rmj8VmlcIzZ8JzZ8LzV8IzV8KzV8JzV8Lzd8Izd8KzSuF5u+E5lVC8/dC8w9C849C809C889C8y9C869C829C8+9C8x9C859C819C899C8z9C879C839C8/9C82qheY3QvFZoXic0rxeaNwjNG4XmTULzZqF5i9C8VWjeJjRvF5p3CM07heZdmZgvSWjenYn50oTmPZmYL0to3puJ+fKE5n2ZmK9IaN6fifnKhOYDmZivSmg+mIn56oTmQ5mYr0loPpyJ+dqE5iOZmK9LaD6aifn6hOZjmZhvSGg+non5xoTmE5mY+xKaTyY093W309s1D4+MiBQixUgpwjUh10hcM3AOzTkl51icc3AM5pjEPpp9Fv/D/Kb5jvvO+ntu6r6PioyOjImMjYyLjI9MiEyMTIpMjkyJTI1Mi0yPzIjMjMyKzI7MicyNzIvMjzDjnpnvfInMBGdGNjOjmaHMTGFm7DYizGBlJikzOplZyQxHZhoy4+/0zDtmoi2MMDOLGVLMVGLGEDN3mEHDTBZmlDCzgxkWzHRgxgE9/xdF6AlPj3R6htNDm57S9FheHKEHLz1p6dFKz1J6eNLTkh6P9DxcEqEnXjtCzzR6iNFTix5T9FyiBxE9eehRQ88WepjQ04MeF/R8WB6hJwBr5Fkzzhpq1hSzxnZFhDWYrElkjR5r1ljDxZom1viw5mVlhDURqyLUzFNDTk01NcbU3FKDSk0mNYrU7FHDRk0XNU7U/FADQ00INRLUDPAMnWfKPGPlmSPP4HgmxTMafhPcw+eeNvd4uee5PcI9Me4Rcc+EewhcU3ONyTUX1yCck3OOyjkb5zAc0znGsc9nH8g+gf+R069TXMw0LzyaAAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "read_vote",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [
        {
          "kind": "field"
        }
      ],
      "bytecode": "H4sIAAAAAAAA/7VTWwrCMBDcvI2C/356g3qDnsEbFCx+Cur9scEMHWPwx2Sh7DZJZyazWyUiSt5hZA1V1Mdce1ofcx7+DE98rTDdguEyViTNOud9votuy3vaVTz05G0rHu4P4wpxRfnsI9ZM4UWkGnvJuwPt28o3OGsr5/jursPdmWekd3BtSYMlLb6tliFhBFnDEBd0QFMgn0Khl3sQKPeYnR494d4jfs0o+DfLg3/m8bzdp+t8nqeLIohypDTBcM1jD/t5NHEWe0G+JTbzo8RVRU7xAo43T8Z8BQAA",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "receive_vote",
      "functionType": "open",
      "isInternal": false,
      "parameters": [
        {
          "name": "vote",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "struct",
          "path": "aztec::abi::PublicCircuitPublicInputs",
          "fields": [
            {
              "name": "call_context",
              "type": {
                "kind": "struct",
                "path": "aztec::abi::CallContext",
                "fields": [
                  {
                    "name": "msg_sender",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "storage_contract_address",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "portal_contract_address",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "function_selector",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "is_delegate_call",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "is_static_call",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "is_contract_deployment",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ]
              }
            },
            {
              "name": "args_hash",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "return_values",
              "type": {
                "kind": "array",
                "length": 4,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "contract_storage_update_requests",
              "type": {
                "kind": "array",
                "length": 16,
                "type": {
                  "kind": "struct",
                  "path": "aztec::abi::ContractStorageUpdateRequest",
                  "fields": [
                    {
                      "name": "storage_slot",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "old_value",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "new_value",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              }
            },
            {
              "name": "contract_storage_read",
              "type": {
                "kind": "array",
                "length": 16,
                "type": {
                  "kind": "struct",
                  "path": "aztec::abi::ContractStorageRead",
                  "fields": [
                    {
                      "name": "storage_slot",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "value",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              }
            },
            {
              "name": "public_call_stack",
              "type": {
                "kind": "array",
                "length": 4,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "new_commitments",
              "type": {
                "kind": "array",
                "length": 16,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "new_nullifiers",
              "type": {
                "kind": "array",
                "length": 16,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "new_l2_to_l1_msgs",
              "type": {
                "kind": "array",
                "length": 2,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "unencrypted_logs_hash",
              "type": {
                "kind": "array",
                "length": 2,
                "type": {
                  "kind": "field"
                }
              }
            },
            {
              "name": "unencrypted_log_preimages_length",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "block_data",
              "type": {
                "kind": "struct",
                "path": "aztec::abi::HistoricBlockData",
                "fields": [
                  {
                    "name": "note_hash_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nullifier_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "contract_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "l1_to_l2_messages_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "blocks_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "public_data_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "global_variables_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            },
            {
              "name": "prover_address",
              "type": {
                "kind": "field"
              }
            }
          ]
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "events": [],
  "debug": {
    "debugSymbols": [
      "eJyrVsrJT04syczPK1ayqq6tBQAz9wY7",
      "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"
    ],
    "fileMap": {
      "1": {
        "source": "contract Tallier {\n\n    use dep::aztec::{\n        context::{PublicContext, Context},\n        state_vars::{public_state::PublicState},\n        types::type_serialization::{\n            field_serialization::{FieldSerializationMethods, FIELD_SERIALIZED_LEN},\n        }\n    };\n\n\n    struct Storage {\n        vote1: PublicState<Field, FIELD_SERIALIZED_LEN>\n    }\n\n    impl Storage {\n        fn init(context: Context) -> Self {\n            Storage {\n                vote1: PublicState::new(context, 1, FieldSerializationMethods)\n            }\n        }\n    }\n\n    #[aztec(private)]\n    fn constructor() {}\n\n    #[aztec(public)]\n    fn receive_vote(\n        vote: Field,\n    ) -> Field{\n        storage.vote1.write(vote);\n    }\n\n    unconstrained fn read_vote() -> Field {\n        storage.vote1.read()\n    }\n}\n",
        "path": "/home/filip/c/pebbles/packages/voting/src/contracts/tallier/src/main.nr"
      },
      "31": {
        "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
        "path": "std/option.nr"
      },
      "34": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\nuse crate::hash::pedersen_hash;\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n// docs:end:contract-deployment-data\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n    function_selector: Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.function_selector,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\n// docs:start:historic-block-data\nstruct HistoricBlockData {\n    note_hash_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n// docs:end:historic-block-data\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    pub fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    pub fn empty() -> Self {\n        Self { note_hash_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    pending_read_requests: [Field; crate::abi::MAX_PENDING_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        pedersen_hash(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    pub fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize());\n        inputs.push(self.prover_address);\n\n        pedersen_hash(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    pub fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n",
        "path": "/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.12.0/yarn-project/aztec-nr/aztec/src/abi.nr"
      },
      "37": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n    pending_read_requests: BoundedVec<Field, MAX_PENDING_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n            pending_read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            pending_read_requests: self.pending_read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    pub fn push_pending_read_request(&mut self, pending_read_request: Field) {\n        self.pending_read_requests.push(pending_read_request);\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    // We never push a zero nullified_commitment as zero is used to indicate the end\n    // of a field array in private kernel. This routine transparently replaces a\n    // zero value into the special placeholder: EMPTY_NULLIFIED_COMMITMENT.\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        let mut non_zero_nullified = nullified_commitment;\n        if (non_zero_nullified == 0) {\n            non_zero_nullified = EMPTY_NULLIFIED_COMMITMENT;\n        }\n        self.nullified_commitments.push(non_zero_nullified);\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, self.this_address(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[12],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 13),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 17),\n                pending_read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 49),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 81),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 97),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 113),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 129),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 133),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 137),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 139),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 141),\n                encrypted_log_preimages_length: fields[143],\n                unencrypted_log_preimages_length: fields[144],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    note_hash_tree_root : fields[145],\n                    nullifier_tree_root : fields[146],\n                    contract_tree_root : fields[147],\n                    l1_to_l2_messages_tree_root : fields[148],\n                    blocks_tree_root : fields[149],\n                    public_data_tree_root: fields[150],\n                    global_variables_hash: fields[151],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[152], fields[153]),\n                    constructor_vk_hash : fields[154],\n                    function_tree_root : fields[155],\n                    contract_address_salt : fields[156],\n                    portal_contract_address : fields[157],\n                },\n                chain_id: fields[158],\n                version: fields[159],\n            },\n            is_execution_request: fields[160] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                args_hash: fields[12],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}",
        "path": "/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.12.0/yarn-project/aztec-nr/aztec/src/context.nr"
      },
      "38": {
        "source": "use dep::std::hash::{pedersen_hash_with_separator, sha256};\nuse crate::constants_gen::{\n  GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n  GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET,\n};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n  let sha256_hashed = sha256(bytes_to_hash);\n\n  // Convert it to a field element\n  let mut v = 1;\n  let mut high = 0 as Field;\n  let mut low = 0 as Field;\n\n  for i in 0..16 {\n      high = high + (sha256_hashed[15 - i] as Field) * v;\n      low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n      v = v * 256;\n  }\n\n  // Abuse that a % p + b % p = (a + b) % p and that low < p\n  let hash_in_a_field = low + high * v;\n\n  hash_in_a_field\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n  // TODO(#1205) This is probably not the right index to use\n  pedersen_hash([secret], GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET)\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n  pedersen_hash_with_separator(inputs, hash_index)\n}",
        "path": "/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.12.0/yarn-project/aztec-nr/aztec/src/hash.nr"
      },
      "64": {
        "source": "\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(\n    _storage_slot: Field,\n    _number_of_elements: Field,\n) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field)-> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<T, N>(\n    storage_slot: Field,\n    deserialize: fn ([Field; N]) -> T,\n) -> T {\n    let fields = storage_read_oracle_wrapper(storage_slot);\n    deserialize(fields)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(\n    _storage_slot: Field,\n    _values: [Field; N],\n) -> [Field; N] {}\n\n// TODO: Remove return value.\nunconstrained pub fn storage_write<N>(\n    storage_slot: Field,\n    fields: [Field; N]\n) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}",
        "path": "/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.12.0/yarn-project/aztec-nr/aztec/src/oracle/storage.nr"
      },
      "72": {
        "source": "use crate::context::{Context};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse crate::types::type_serialization::TypeSerializationInterface;\nuse dep::std::option::Option;\n\n// docs:start:public_state_struct\nstruct PublicState<T, T_SERIALIZED_LEN> {\n    context: Context,\n    storage_slot: Field,\n    serialization_methods: TypeSerializationInterface<T, T_SERIALIZED_LEN>,\n}\n// docs:end:public_state_struct\n\nimpl<T, T_SERIALIZED_LEN> PublicState<T, T_SERIALIZED_LEN> {\n    // docs:start:public_state_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n        serialization_methods: TypeSerializationInterface<T, T_SERIALIZED_LEN>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicState {\n            context,\n            storage_slot,\n            serialization_methods,\n        }\n    }\n    // docs:end:public_state_struct_new\n\n    // docs:start:public_state_struct_read\n    pub fn read(self) -> T {\n        assert(self.context.private.is_none(), \"Public state writes only supported in public functions\");\n        storage_read(self.storage_slot, self.serialization_methods.deserialize)\n    }\n    // docs:end:public_state_struct_read\n\n    // docs:start:public_state_struct_write\n    pub fn write(self, value: T) {\n        assert(self.context.private.is_none(), \"Public state writes only supported in public functions\");\n        let serialize = self.serialization_methods.serialize;\n        let fields = serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_state_struct_write\n}\n",
        "path": "/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.12.0/yarn-project/aztec-nr/aztec/src/state_vars/public_state.nr"
      },
      "81": {
        "source": "use crate::types::type_serialization::TypeSerializationInterface;\n\n// docs:start:field_serialization\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nfn deserializeField(fields: [Field; FIELD_SERIALIZED_LEN]) -> Field {\n    fields[0]\n}\n\nfn serializeField(value: Field) -> [Field; FIELD_SERIALIZED_LEN] {\n    [value]\n}\n\nglobal FieldSerializationMethods = TypeSerializationInterface {\n    deserialize: deserializeField,\n    serialize: serializeField,\n};\n// docs:end:field_serialization",
        "path": "/home/filip/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.12.0/yarn-project/aztec-nr/aztec/src/types/type_serialization/field_serialization.nr"
      }
    }
  }
}